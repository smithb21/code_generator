use std::fmt;
use crate::setup::*;

/// Indentation generator
/// 
/// This struct will use the context of the generator to decide how to generate
/// 
/// When using this generator you should assume that any necessary indentation
/// before your generator has already been created. i.e. generate indentation
/// for all lines except the first since that indentation would be generated by
/// the parent generator. You will only need to use this when you create a
/// multiline generator which does not use the existing code structure
/// generators.
#[derive(Clone, Copy)]
pub struct Indentation {
}

impl Indentation {
    /// Creates an indentation generator
    /// 
    /// This should not be used if you want a specific amount/type of indentation
    /// 
    /// ```
    /// # use code_generator::CodeStyle;
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::Indentation;
    /// # use code_generator::DisplayExt;
    /// #
    /// let indent = Indentation::new();
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR).indent();
    /// assert_eq!("    ", format!("{}", indent.display(info)));
    /// ```
    pub fn new() -> Indentation {
        Indentation { }
    }
}

impl CodeGenerate for Indentation {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let indent ;
        match info.indent_type {
            IndentationType::Spaces => indent = " ".repeat(info.indent_amount*info.indent_level),
            IndentationType::Tabs => indent = "	".repeat(
                ((info.indent_amount+3) / 4) * info.indent_level
            ),
        }
        
        write!(f, "{}", indent)
    }
}

/// The name type allows the struct to use the generation info to decide the
/// case type of the name based on the type of name.
/// 
/// The FixedCase variant is used to override the CaseType discovery of normal
/// code generation.
/// 
/// The Bypass variant is used to provide a name without having the generator
/// use any sort of formatting on it.
#[derive(Clone, Copy)]
pub enum NameType {
    Default,
    ConstDefine,
    Type,
    Member,
    Function,
    File,
    FixedCase(CaseType),
    Bypass,
}

#[derive(Clone)]
pub struct Name {
    parts: Vec<String>,
    name_type: NameType
}

impl Name {
    fn is_separator(char: char, prev: Option<char>) -> bool {
        char.is_uppercase() 
        && prev.is_some_and(
            |char| char.is_lowercase()
        )
    }

    /// Creates a Name generator
    /// 
    /// This struct makes it easy to change the name format based on the
    /// context of the generator.
    /// 
    /// ```
    /// # use code_generator::CaseType;
    /// # use code_generator::CodeStyle;
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::Name;
    /// # use code_generator::NameType;
    /// # use code_generator::DisplayExt;
    /// #
    /// let cc = NameType::FixedCase(CaseType::CamelCase);
    /// let name = Name::new("test_name1").with_type(cc);
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR);
    /// assert_eq!("test_Name1", format!("{}", name.display(info)));
    ///
    /// let ssc = NameType::FixedCase(CaseType::ScreamingSnakeCase);
    /// let name = Name::new("test_name2").with_type(ssc);
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR);
    /// assert_eq!("TEST__NAME2", format!("{}", name.display(info)));
    ///
    /// let ssc = NameType::FixedCase(CaseType::SnakeCase);
    /// let name = Name::new("testNameThree").with_type(ssc);
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR);
    /// assert_eq!("test_name_three", format!("{}", name.display(info)));
    ///
    /// let ssc = NameType::FixedCase(CaseType::FlatCase);
    /// let name = Name::new("test_four").with_type(ssc);
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR);
    /// assert_eq!("test_four", format!("{}", name.display(info)));
    /// ```
    pub fn new(name: &str) -> Name {
        let mut parts: Vec<String> = Vec::new();
        let mut current_part = String::new();
        let mut is_first = true;
        let mut prev = None;
        for char in name.chars() {
            if Self::is_separator(char, prev) && !is_first {
                parts.push(current_part.clone());
                current_part.clear();
            }

            current_part.extend(char.to_lowercase());
            if char == '_' {
                parts.push(current_part.clone());
                current_part.clear();
            }
            is_first = false;
            prev = Some(char);
        }
        // push last part
        if !current_part.is_empty() {
            parts.push(current_part);
        }

        Name {
            parts: parts,
            name_type: NameType::Default
        }
    }

    pub fn new_with_type(snake_case_name: &str, name_type: NameType) -> Name {
        if let NameType::Bypass = name_type {
            Name {
                parts: vec![snake_case_name.into()],
                name_type: NameType::Bypass
            }
        } else {
            Name::new(snake_case_name).with_type(name_type)
        }
    }

    pub fn with_type(mut self, name_type: NameType) -> Name {
        match self.name_type {
            // Fixed/Bypass case bypasses the name type specialization
            NameType::Bypass => (),
            NameType::FixedCase(_) => (),
            _ => self.name_type = name_type,
        }

        self
    }

    /// Creates a Name generator
    /// 
    /// This struct makes it easy to change the name format based on the
    /// context of the generator.
    /// 
    /// ```
    /// # use code_generator::CaseType;
    /// # use code_generator::CodeStyle;
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::Name;
    /// # use code_generator::NameType;
    /// # use code_generator::DisplayExt;
    /// # use code_generator::CaseTypes;
    /// #
    /// let name = Name::new("test_name1").as_include_guard();
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR)
    ///     .with_case_types(
    ///         CaseTypes::new().with_const_define(CaseType::ScreamingSnakeCase)
    ///     );
    /// assert_eq!("TEST__NAME1_H", format!("{}", name.display(info)));
    pub fn as_include_guard(&self) -> Name {
        let mut parts = self.parts.clone();
        parts.push(String::from("h"));
        Name { parts: parts, name_type: NameType::ConstDefine }
    }

    fn caps_first_letter(string: String) -> String {
        let mut result = String::new();

        let mut iter = string.chars();
        if let Some(char) = iter.next() {
            result.push(char.to_ascii_uppercase());
        }

        for char in iter {
            result.push(char);
        }

        result
    }

    fn casify(&self, case: CaseType) -> String {
        if let NameType::Bypass = self.name_type {
            return self.parts.join("");
        }

        let mut parts = Vec::new();
        let mut is_first = true;
        for part in self.parts.iter() {
            parts.push (match case {
                CaseType::CamelCase => if is_first {part.clone()} else {Self::caps_first_letter(part.clone())},
                CaseType::FlatCase => part.clone(),
                CaseType::PascalCase => Self::caps_first_letter(part.clone()),
                CaseType::ScreamingCase => part.to_ascii_uppercase(),
                CaseType::ScreamingSnakeCase => part.to_ascii_uppercase(),
                CaseType::SnakeCase => part.clone(),
            });
            is_first = false;
        }
        match case {
            CaseType::CamelCase => parts.join(""),
            CaseType::FlatCase => parts.join(""),
            CaseType::PascalCase => parts.join(""),
            CaseType::ScreamingCase => parts.join(""),
            CaseType::ScreamingSnakeCase => parts.join("_"),
            CaseType::SnakeCase => parts.join("_"),
        }
    }

    fn get_case_type(&self, info: CaseTypes) -> CaseType {
        match self.name_type {
            NameType::Default => info.default_case,
            NameType::ConstDefine => info.const_define_case,
            NameType::Function => info.function_name_case,
            NameType::Member => info.member_name_case,
            NameType::Type => info.type_name_case,
            NameType::File => info.file_name_case,
            NameType::FixedCase(case) => case,
            NameType::Bypass => info.default_case,
        }
    }
}

impl CodeGenerate for Name {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let case_type = self.get_case_type(info.case_types);
        write!(f, "{}", self.casify(case_type))
    }
}

pub struct Include {
    file_name: Name,
    is_sys_inc: bool,
}

impl Include {
    
    /// Creates an Include generator
    /// 
    /// This struct allows includes to be adapted to the naming of the config
    /// 
    /// ```
    /// # use code_generator::CaseType;
    /// # use code_generator::CodeStyle;
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::Name;
    /// # use code_generator::NameType;
    /// # use code_generator::DisplayExt;
    /// # use code_generator::Include;
    /// #
    /// let inc = Include::new(Name::new_with_type("my_testFile", NameType::File));
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR);
    /// assert_eq!("#include \"My_TestFile.h\"", format!("{}", inc.display(info)));
    /// ```
    pub fn new(file_name: Name) -> Include {
        Include {
            file_name,
            is_sys_inc: false
        }
    }

    /// Creates an Include generator
    /// 
    /// This struct allows includes to be adapted to the naming of the config
    /// 
    /// ```
    /// # use code_generator::CaseType;
    /// # use code_generator::CodeStyle;
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::Name;
    /// # use code_generator::NameType;
    /// # use code_generator::DisplayExt;
    /// # use code_generator::Include;
    /// #
    /// let inc = Include::new_sys("my_testFile.h");
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR);
    /// assert_eq!("#include <my_testFile.h>", format!("{}", inc.display(info)));
    /// ```
    pub fn new_sys(file_name: &str) -> Include {
        Include {
            file_name: Name::new_with_type(
                file_name,
                NameType::Bypass
            ),
            is_sys_inc: true
        }
    }
}

impl CodeGenerate for Include {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        match self.is_sys_inc {
            true => write!(f, "#include <{}>", self.file_name.display(info)),
            false => write!(f, "#include \"{}.h\"", self.file_name.display(info))
        }
    }
}

/// The NewLine struct allows the generation info to decide the new line format
#[derive(Clone, Copy)]
pub struct NewLine {
}

impl NewLine {
    /// Creates a NewLine generator
    /// 
    /// This struct makes it easy to change the new line format based on the
    /// context of the generator.
    /// 
    /// ```
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::NewLineType;
    /// # use code_generator::NewLine;
    /// # use code_generator::DisplayExt;
    /// #
    /// let new_line = NewLine::new();
    /// let mut info = CodeGenerationInfo::new();
    /// info.set_new_line_type(NewLineType::CrNl);
    /// assert_eq!("\r\n", format!("{}", new_line.display(info)));
    /// ```
    pub fn new() -> NewLine {
        NewLine { }
    }
}

impl CodeGenerate for NewLine {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        match info.new_line_type {
            NewLineType::Cr => write!(f, "\r"),
            NewLineType::Nl => write!(f, "\n"),
            NewLineType::CrNl => write!(f, "\r\n"),
            NewLineType::None => write!(f, ""),
        }
    }
}

pub struct CodeSet {
    code_set: Vec<Box<dyn CodeGenerate>>,
    is_separated: bool,
}

impl CodeSet {
    pub fn new(set: Vec<Box<dyn CodeGenerate>>) -> CodeSet {
        CodeSet { code_set: set, is_separated: false }
    }

    pub fn new_separated(set: Vec<Box<dyn CodeGenerate>>) -> CodeSet {
        CodeSet { code_set: set, is_separated: true }
    }
}

impl CodeGenerate for CodeSet {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let mut result = fmt::Result::Ok(());
        let mut iter = self.code_set.iter();
        if let Some(item) = iter.next() {
            result = result.and(item.generate(f, info));

            for item in iter {
                result = result.and(NewLine::new().generate(f, info));
                if self.is_separated {
                    result = result.and(NewLine::new().generate(f, info));
                }
                result = result.and(Indentation::new().generate(f, info));
                result = result.and(item.generate(f, info));
            }
        }
        result
    }
}

/// The JoinedCode struct joins multiple sections of code with no further
/// formatting, or configuration done outside, inside, or between units.
pub struct JoinedCode {
    code_set: Vec<Box<dyn CodeGenerate>>,
}

impl JoinedCode {
    /// Creates a JoinedCode generator
    /// 
    /// This struct makes it easy to join multiple generators without any separation
    /// 
    /// ```
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::DisplayExt;
    /// # use code_generator::JoinedCode;
    /// #
    /// let joined = JoinedCode::new(vec![
    ///     Box::new(String::from("This")),
    ///     Box::new(String::from(":")),
    ///     Box::new(String::from("Is")),
    ///     Box::new(String::from(":")),
    ///     Box::new(String::from("Joined"))
    /// ]);
    /// let mut info = CodeGenerationInfo::new();
    /// assert_eq!("This:Is:Joined", format!("{}", joined.display(info)));
    /// ```
    pub fn new(set: Vec<Box<dyn CodeGenerate>>) -> JoinedCode {
        JoinedCode { code_set: set }
    }
}

impl CodeGenerate for JoinedCode {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let mut result = fmt::Result::Ok(());

        for item in self.code_set.iter() {
            result = result.and(item.generate(f, info));
        }

        result
    }
}

/// Creates a JoinedCode generator
/// 
/// This macro makes it easy to create a JoinedCode struct
/// 
/// ```
/// # use code_generator::CodeGenerationInfo;
/// # use code_generator::DisplayExt;
/// # use code_generator::JoinedCode;
/// # use code_generator::CodeGenerate;
/// # use code_generator::join_code;
/// #
/// let joined = join_code!(
///     String::from("This"),
///     String::from("Is"),
///     String::from("Joined")
/// );
///
/// let mut info = CodeGenerationInfo::new();
/// assert_eq!("ThisIsJoined", format!("{}", JoinedCode::new(joined).display(info)));
/// ```
#[macro_export]
macro_rules! join_code {
    ($($args:expr),*) => {{
        let temp: Vec<Box<dyn CodeGenerate>> = vec![
            $(Box::new($args)),*
        ];

        temp
    }}
}

/// Raw code with no formatting besides injecting newlines, and
/// indentation based on the context
impl CodeGenerate for String {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let mut result: fmt::Result = fmt::Result::Ok(());
        // First line doesn't print indentation
        let mut iter = self.lines();
        if let Some(line) = iter.next() {
            result = result.and(result.and(write!(f, "{}", line)));
        }
        for line in iter {
            result = result.and(NewLine::new().generate(f, info));
            result = result.and(Indentation::new().generate(f, info));
            result = result.and(write!(f, "{}", line));
        }
        return result;
    }
}

/// Raw code with no formatting besides injecting newlines, and
/// indentation based on the context/// Creates a JoinedCode generator
/// ```
/// # use code_generator::CodeGenerationInfo;
/// # use code_generator::DisplayExt;
/// # use code_generator::JoinedCode;
/// # use code_generator::CodeGenerate;
/// # use code_generator::join_code;
/// #
/// let text = "Testing123";
///
/// let mut info = CodeGenerationInfo::new();
/// assert_eq!("Testing123", format!("{}", text.display(info)));
/// ```
impl CodeGenerate for &str {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let mut result: fmt::Result = fmt::Result::Ok(());
        // First line doesn't print indentation
        let mut iter = self.lines();
        if let Some(line) = iter.next() {
            result = result.and(result.and(write!(f, "{}", line)));
        }
        for line in iter {
            result = result.and(NewLine::new().generate(f, info));
            result = result.and(Indentation::new().generate(f, info));
            result = result.and(write!(f, "{}", line));
        }
        return result;
    }
}

pub struct SeparatedCode {
    items: Vec<Box<dyn CodeGenerate>>,
    separator: Box<dyn CodeGenerate>,
    // TODO: newlines in GeneratorInfo?
}

impl SeparatedCode {
    pub fn new(items: Vec<Box<dyn CodeGenerate>>, separator: Box<dyn CodeGenerate>) -> SeparatedCode {
        SeparatedCode { items: items, separator: separator }
    }
}

impl CodeGenerate for SeparatedCode {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let mut result: fmt::Result = fmt::Result::Ok(());

        let mut iterator = self.items.iter();

        if let Some(item) = iterator.next() {
            result = result.and(item.generate(f, info));
        }

        for item in iterator {
            result = result.and(self.separator.generate(f, info));
            result = result.and(item.generate(f, info));
        }

        result
    }
}

pub struct CodeBody {
    raw_code: CodeSet,
}

impl CodeBody {
    /// Creates a CodeBody generator
    /// 
    /// This struct is used for code bodies. Think the body to an if statement,
    /// function, or struct. This handles the brace/newline format of that body
    /// 
    /// ```
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::CodeStyle;
    /// # use code_generator::DisplayExt;
    /// # use code_generator::CodeBody;
    /// #
    /// let code_body = CodeBody::new(vec![
    ///     Box::new(String::from("Body"))
    /// ]);
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR);
    /// assert_eq!("{\r\n    Body\r\n}", format!("{}", code_body.display(info)));
    /// 
    /// let info = CodeGenerationInfo::from_style(CodeStyle::Horstmann);
    /// assert_eq!("{   Body\r\n}", format!("{}", code_body.display(info)));
    /// ```
    pub fn new(code: Vec<Box<dyn CodeGenerate>>) -> CodeBody {
        CodeBody {raw_code: CodeSet::new(code)}
    }
}

impl CodeGenerate for CodeBody {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let mut result: fmt::Result = fmt::Result::Ok(());
        match info.indent_style {
            IndentationStyle::Allman => {
                result = result.and(Indentation::new().generate(f, info));
                result = result.and(write!(f, "{{"));
                result = result.and(NewLine::new().generate(f, info));
                result = result.and(Indentation::new().generate(f, info.indent()));
                result = result.and(self.raw_code.generate(f, info.indent()));
                result = result.and(NewLine::new().generate(f, info));
                result = result.and(Indentation::new().generate(f, info));
                result = result.and(write!(f, "}}"));
            }
            IndentationStyle::GNU => {
                result = result.and(write!(f, "{{"));
                result = result.and(NewLine::new().generate(f, info));
                result = result.and(Indentation::new().generate(f, info.indent().indent()));
                result = result.and(self.raw_code.generate(f, info.indent().indent()));
                result = result.and(NewLine::new().generate(f, info));
                if info.context != GeneratorContext::Function {
                    result = result.and(Indentation::new().generate(f, info.indent()));
                }
                result = result.and(write!(f, "}}"));
            }
            IndentationStyle::Horstmann => {
                result = result.and(Indentation::new().generate(f, info));
                result = result.and(write!(f, "{{"));
                let mut temp_info = info;
                temp_info.indent_level = 1;
                temp_info.indent_amount -= 1;// to account for '{' if using spaces
                result = result.and(Indentation::new().generate(f, temp_info));
                result = result.and(self.raw_code.generate(f, info.indent()));
                result = result.and(NewLine::new().generate(f, info));
                result = result.and(Indentation::new().generate(f, info));
                result = result.and(write!(f, "}}"));
            }
            IndentationStyle::KnR => {
                result = result.and(write!(f, "{{"));
                result = result.and(NewLine::new().generate(f, info));
                result = result.and(Indentation::new().generate(f, info.indent()));
                result = result.and(self.raw_code.generate(f, info.indent()));
                result = result.and(NewLine::new().generate(f, info));
                result = result.and(Indentation::new().generate(f, info));
                result = result.and(write!(f, "}}"));
            }
            IndentationStyle::Pico => {
                result = result.and(Indentation::new().generate(f, info));
                result = result.and(write!(f, "{{"));
                let mut temp_info = info;
                temp_info.indent_level = 1;
                temp_info.indent_amount -= 1;// to account for '{' if using spaces
                result = result.and(Indentation::new().generate(f, temp_info));
                result = result.and(self.raw_code.generate(f, info.indent()));
                //result = result.and(Indentation::new().generate(f, info));
                result = result.and(write!(f, " }}"));
            }
            IndentationStyle::None => {
                result = result.and(write!(f, "{{"));
                result = result.and(self.raw_code.generate(f, info.indent()));
                result = result.and(write!(f, "}}"));
            }
            _ => result = result.and(write!(f, "NOT SUPPORTED YET!")),
        }

        result
    }
}

pub struct HeaderPlusBody<HT> {
    header: HT,
    body: CodeBody,
}

impl<HT> HeaderPlusBody<HT> {
    /// Creates a HeaderPlusBody generator
    /// 
    /// This struct is used for joining headers and bodies. For example joining
    /// the "if(condition)" to the "{body}"
    /// 
    /// ```
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::CodeStyle;
    /// # use code_generator::DisplayExt;
    /// # use code_generator::CodeBody;
    /// # use code_generator::HeaderPlusBody;
    /// #
    /// let header_plus_body = HeaderPlusBody::new(
    ///     String::from("header"),
    ///     CodeBody::new(vec![Box::new(String::from("Body"))])
    /// );
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR);
    /// assert_eq!(
    ///     "header {\r\n    Body\r\n}",
    ///     format!("{}", header_plus_body.display(info))
    /// );
    /// 
    /// let info = CodeGenerationInfo::from_style(CodeStyle::Allman);
    /// assert_eq!(
    ///     "header\r\n{\r\n    Body\r\n}",
    ///     format!("{}", header_plus_body.display(info))
    /// );
    /// ```
    pub fn new(header: HT, body: CodeBody) -> HeaderPlusBody<HT>{
        HeaderPlusBody {header: header, body: body}
    }
}

impl<HT> CodeGenerate for HeaderPlusBody<HT>
where HT: CodeGenerate,{
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let mut result: fmt::Result = fmt::Result::Ok(());
        result = result.and(self.header.generate(f, info));
        match info.indent_style {
            IndentationStyle::Allman |
            IndentationStyle::Horstmann |
            IndentationStyle::Pico => {
                result = result.and(NewLine::new().generate(f, info));
            },
            IndentationStyle::GNU => {
                result = result.and(NewLine::new().generate(f, info));
                if info.context != GeneratorContext::Function {
                    result = result.and(Indentation::new().generate(f, info.indent()));
                }
            }
            IndentationStyle::KnR => {
                result = result.and(write!(f, " "));
            }
            _ => (),
        }
        result = result.and(self.body.generate(f, info));
        result
    }
}
