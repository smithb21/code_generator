use std::fmt;
use crate::iterable::GetIter;
use crate::setup::*;
use crate::as_case::AsCase;

/// Indentation generator
/// 
/// This struct will use the context of the generator to decide how to generate
/// 
/// When using this generator you should assume that any necessary indentation
/// before your generator has already been created. i.e. generate indentation
/// for all lines except the first since that indentation would be generated by
/// the parent generator. You will only need to use this when you create a
/// multiline generator which does not use the existing code structure
/// generators.
#[derive(Clone, Copy)]
pub struct Indentation {
}

impl Indentation {
    /// Creates an indentation generator
    /// 
    /// This should not be used if you want a specific amount/type of indentation
    /// 
    /// ```
    /// # use code_generator::CodeStyle;
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::Indentation;
    /// # use code_generator::DisplayExt;
    /// #
    /// let indent = Indentation::new();
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR).indent();
    /// assert_eq!("    ", format!("{}", indent.display(info)));
    /// ```
    pub fn new() -> Indentation {
        Indentation { }
    }
}

impl CodeGenerate for Indentation {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let indent ;
        match info.indent_type {
            IndentationType::Spaces => indent = " ".repeat(info.indent_amount*info.indent_level),
            IndentationType::Tabs => indent = "	".repeat(
                ((info.indent_amount+3) / 4) * info.indent_level
            ),
        }
        
        write!(f, "{}", indent)
    }
}

/// The name type allows the struct to use the generation info to decide the
/// case type of the name based on the type of name.
/// 
/// The FixedCase variant is used to override the CaseType discovery of normal
/// code generation.
/// 
/// The Bypass variant is used to provide a name without having the generator
/// use any sort of formatting on it.
#[derive(Clone, Copy)]
pub enum NameType {
    Default,
    ConstDefine,
    Type,
    Member,
    Function,
    File,
    FixedCase(CaseType),
    Bypass,
}

#[derive(Copy, Clone)]
pub struct Name<'a> {
    source: &'a str,
    name_type: NameType
}

impl<'a> Name<'a> {
    /// Creates a Name generator
    /// 
    /// This struct makes it easy to change the name format based on the
    /// context of the generator.
    /// 
    /// ```
    /// # use code_generator::CaseType;
    /// # use code_generator::CodeStyle;
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::Name;
    /// # use code_generator::NameType;
    /// # use code_generator::DisplayExt;
    /// #
    /// let cc = NameType::FixedCase(CaseType::CamelCase);
    /// let name = Name::new("test_name1").with_type(cc);
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR);
    /// assert_eq!("test_Name1", format!("{}", name.display(info)));
    ///
    /// let ssc = NameType::FixedCase(CaseType::ScreamingSnakeCase);
    /// let name = Name::new("test_name2").with_type(ssc);
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR);
    /// assert_eq!("TEST__NAME2", format!("{}", name.display(info)));
    ///
    /// let ssc = NameType::FixedCase(CaseType::SnakeCase);
    /// let name = Name::new("testNameThree").with_type(ssc);
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR);
    /// assert_eq!("test_name_three", format!("{}", name.display(info)));
    ///
    /// let ssc = NameType::FixedCase(CaseType::FlatCase);
    /// let name = Name::new("test_four").with_type(ssc);
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR);
    /// assert_eq!("test_four", format!("{}", name.display(info)));
    /// ```
    pub fn new(name: &'a str) -> Name<'a> {
        Name {
            source: name.into(),
            name_type: NameType::Default
        }
    }

    pub fn new_with_type(name: &'a str, name_type: NameType) -> Name<'a> {
        Name::new(name).with_type(name_type)
    }

    pub fn with_type(mut self, name_type: NameType) -> Name<'a> {
        match self.name_type {
            // Fixed/Bypass case bypasses the name type specialization
            NameType::Bypass => (),
            NameType::FixedCase(_) => (),
            _ => self.name_type = name_type,
        }

        self
    }

    fn get_case_type(&self, info: CaseTypes) -> CaseType {
        match self.name_type {
            NameType::Default => info.default_case,
            NameType::ConstDefine => info.const_define_case,
            NameType::Function => info.function_name_case,
            NameType::Member => info.member_name_case,
            NameType::Type => info.type_name_case,
            NameType::File => info.file_name_case,
            NameType::FixedCase(case) => case,
            NameType::Bypass => info.default_case,
        }
    }
}

impl<'a> CodeGenerate for Name<'a> {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let case_type = self.get_case_type(info.case_types);
        write!(f, "{}", self.source.as_case(case_type))
    }
}

pub struct Include<'a> {
    file_name: Name<'a>,
    is_sys_inc: bool,
}

impl<'a> Include<'a> {
    
    /// Creates an Include generator
    /// 
    /// This struct allows includes to be adapted to the naming of the config
    /// 
    /// ```
    /// # use code_generator::CaseType;
    /// # use code_generator::CodeStyle;
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::Name;
    /// # use code_generator::NameType;
    /// # use code_generator::DisplayExt;
    /// # use code_generator::Include;
    /// #
    /// let inc = Include::new(Name::new_with_type("my_testFile", NameType::File));
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR);
    /// assert_eq!("#include \"My_TestFile.h\"", format!("{}", inc.display(info)));
    /// ```
    pub fn new(file_name: Name) -> Include {
        Include {
            file_name,
            is_sys_inc: false
        }
    }

    /// Creates an Include generator
    /// 
    /// This struct allows includes to be adapted to the naming of the config
    /// 
    /// ```
    /// # use code_generator::CaseType;
    /// # use code_generator::CodeStyle;
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::Name;
    /// # use code_generator::NameType;
    /// # use code_generator::DisplayExt;
    /// # use code_generator::Include;
    /// #
    /// let inc = Include::new_sys("my_testFile.h");
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR);
    /// assert_eq!("#include <my_testFile.h>", format!("{}", inc.display(info)));
    /// ```
    pub fn new_sys(file_name: Name<'a>) -> Include<'a> {
        Include {
            file_name: file_name.with_type(NameType::Bypass),
            is_sys_inc: true
        }
    }
}

impl<'a> CodeGenerate for Include<'a> {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        match self.is_sys_inc {
            true => write!(f, "#include <{}>", self.file_name.display(info)),
            false => write!(f, "#include \"{}.h\"", self.file_name.display(info))
        }
    }
}

/// The NewLine struct allows the generation info to decide the new line format
#[derive(Clone, Copy)]
pub struct NewLine {
}

impl NewLine {
    /// Creates a NewLine generator
    /// 
    /// This struct makes it easy to change the new line format based on the
    /// context of the generator.
    /// 
    /// ```
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::NewLineType;
    /// # use code_generator::NewLine;
    /// # use code_generator::DisplayExt;
    /// #
    /// let new_line = NewLine::new();
    /// let mut info = CodeGenerationInfo::new();
    /// info.set_new_line_type(NewLineType::CrNl);
    /// assert_eq!("\r\n", format!("{}", new_line.display(info)));
    /// ```
    pub fn new() -> NewLine {
        NewLine { }
    }
}

impl CodeGenerate for NewLine {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        match info.new_line_type {
            NewLineType::Cr => write!(f, "\r"),
            NewLineType::Nl => write!(f, "\n"),
            NewLineType::CrNl => write!(f, "\r\n"),
            NewLineType::None => write!(f, ""),
        }
    }
}

#[derive(Copy, Clone)]
pub struct CodeSet<'a, T: GetIter<'a, Item=&'a dyn CodeGenerate>> {
    code_set: &'a T,
    is_separated: bool,
}

impl<'a, T: GetIter<'a, Item=&'a dyn CodeGenerate>> CodeSet<'a, T> {
    pub fn new(
        into: &'a T) -> CodeSet<'a, T> {
        CodeSet { code_set: into, is_separated: false }
    }

    pub fn new_separated(
        into: &'a T) -> CodeSet<'a, T> {
        CodeSet { code_set: into, is_separated: true }
    }
}

impl<'a, T: GetIter<'a, Item=&'a dyn CodeGenerate>> CodeGenerate for CodeSet<'a, T> {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let mut result = fmt::Result::Ok(());
        let mut iter = self.code_set.get_iter();
        if let Some(item) = iter.next() {
            result = result.and(item.generate(f, info));

            for item in iter {
                result = result.and(NewLine::new().generate(f, info));
                if self.is_separated {
                    result = result.and(NewLine::new().generate(f, info));
                }
                result = result.and(Indentation::new().generate(f, info));
                result = result.and(item.generate(f, info));
            }
        }
        result
    }
}

/// The JoinedCode struct joins multiple sections of code with no further
/// formatting, or configuration done outside, inside, or between units.
pub struct JoinedCode<'a, T: GetIter<'a, Item=&'a dyn CodeGenerate>> {
    code_set: &'a T,
}

impl<'a, T: GetIter<'a, Item=&'a dyn CodeGenerate>> JoinedCode<'a, T> {
    /// Creates a JoinedCode generator
    /// 
    /// This struct makes it easy to join multiple generators without any separation
    /// 
    /// ```
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::DisplayExt;
    /// # use code_generator::JoinedCode;
    /// #
    /// let joined = JoinedCode::new(vec![
    ///     Box::new(String::from("This")),
    ///     Box::new(String::from(":")),
    ///     Box::new(String::from("Is")),
    ///     Box::new(String::from(":")),
    ///     Box::new(String::from("Joined"))
    /// ]);
    /// let mut info = CodeGenerationInfo::new();
    /// assert_eq!("This:Is:Joined", format!("{}", joined.display(info)));
    /// ```
    pub fn new(set: &'a T) -> JoinedCode<'a, T> {
        JoinedCode { code_set: set }
    }
}

impl<'a, T: GetIter<'a, Item=&'a dyn CodeGenerate>> CodeGenerate for JoinedCode<'a, T> {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let mut result = fmt::Result::Ok(());

        for item in self.code_set.get_iter() {
            result = result.and(item.generate(f, info));
        }

        result
    }
}

/// Creates a JoinedCode generator
/// 
/// This macro makes it easy to create a JoinedCode struct
/// 
/// ```
/// # use code_generator::CodeGenerationInfo;
/// # use code_generator::DisplayExt;
/// # use code_generator::JoinedCode;
/// # use code_generator::CodeGenerate;
/// # use code_generator::join_code;
/// #
/// let joined = join_code!(
///     String::from("This"),
///     String::from("Is"),
///     String::from("Joined")
/// );
///
/// let mut info = CodeGenerationInfo::new();
/// assert_eq!("ThisIsJoined", format!("{}", JoinedCode::new(joined).display(info)));
/// ```
/*macro_rules! count {
    () => (0usize);
    ( $x:tt $($xs:tt)* ) => (1usize + count!($($xs)*));
}

#[macro_export]
macro_rules! join_code {
    ($($args:expr),*) => {{
        let temp: [&dyn CodeGenerate; count!($($args)*)] = [
            $($args),*
        ];

        temp
    }}
} TODO: Remove or Keep??? */

/// Raw code with no formatting besides injecting newlines, and
/// indentation based on the context
impl CodeGenerate for String {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let mut result: fmt::Result = fmt::Result::Ok(());
        // First line doesn't print indentation
        let mut iter = self.lines();
        if let Some(line) = iter.next() {
            result = result.and(result.and(write!(f, "{}", line)));
        }
        for line in iter {
            result = result.and(NewLine::new().generate(f, info));
            result = result.and(Indentation::new().generate(f, info));
            result = result.and(write!(f, "{}", line));
        }
        return result;
    }
}

/// Raw code with no formatting besides injecting newlines, and
/// indentation based on the context/// Creates a JoinedCode generator
/// ```
/// # use code_generator::CodeGenerationInfo;
/// # use code_generator::DisplayExt;
/// # use code_generator::JoinedCode;
/// # use code_generator::CodeGenerate;
/// # use code_generator::join_code;
/// #
/// let text = "Testing123";
///
/// let mut info = CodeGenerationInfo::new();
/// assert_eq!("Testing123", format!("{}", text.display(info)));
/// ```
impl CodeGenerate for &str {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let mut result: fmt::Result = fmt::Result::Ok(());
        // First line doesn't print indentation
        let mut iter = self.lines();
        if let Some(line) = iter.next() {
            result = result.and(result.and(write!(f, "{}", line)));
        }
        for line in iter {
            result = result.and(NewLine::new().generate(f, info));
            result = result.and(Indentation::new().generate(f, info));
            result = result.and(write!(f, "{}", line));
        }
        return result;
    }
}

pub struct SeparatedCode<'a, T: GetIter<'a, Item=&'a dyn CodeGenerate>> {
    items: &'a T,
    separator: &'a dyn CodeGenerate,
}

impl<'a, T: GetIter<'a, Item=&'a dyn CodeGenerate>> SeparatedCode<'a, T> {
    pub fn new(items: &'a T, separator: &'a dyn CodeGenerate) -> SeparatedCode<'a, T> {
        SeparatedCode { items: items, separator: separator }
    }
}

impl<'a, T: GetIter<'a, Item=&'a dyn CodeGenerate>> CodeGenerate for SeparatedCode<'a, T> {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let mut result: fmt::Result = fmt::Result::Ok(());

        let mut iterator = self.items.get_iter();

        if let Some(item) = iterator.next() {
            result = result.and(item.generate(f, info));
        }

        for item in iterator {
            result = result.and(self.separator.generate(f, info));
            result = result.and(item.generate(f, info));
        }

        result
    }
}

pub struct CodeBody<'a, T: GetIter<'a, Item=&'a dyn CodeGenerate>> {
    raw_code: CodeSet<'a, T>,
}

impl<'a, T: GetIter<'a, Item=&'a dyn CodeGenerate>> CodeBody<'a, T> {
    /// Creates a CodeBody generator
    /// 
    /// This struct is used for code bodies. Think the body to an if statement,
    /// function, or struct. This handles the brace/newline format of that body
    /// 
    /// ```
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::CodeStyle;
    /// # use code_generator::DisplayExt;
    /// # use code_generator::CodeBody;
    /// #
    /// let code_body = CodeBody::new(vec![
    ///     Box::new(String::from("Body"))
    /// ]);
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR);
    /// assert_eq!("{\r\n    Body\r\n}", format!("{}", code_body.display(info)));
    /// 
    /// let info = CodeGenerationInfo::from_style(CodeStyle::Horstmann);
    /// assert_eq!("{   Body\r\n}", format!("{}", code_body.display(info)));
    /// ```
    pub fn new(code: &'a T) -> CodeBody<'a, T> {
        CodeBody {raw_code: CodeSet::new(code)}
    }

    /// Creates a CodeBody generator
    /// 
    /// This struct is used for code bodies. Think the body to an if statement,
    /// function, or struct. This handles the brace/newline format of that body
    /// 
    /// ```
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::CodeStyle;
    /// # use code_generator::DisplayExt;
    /// # use code_generator::CodeBody;
    /// # use code_generator::CodeSet;
    /// #
    /// let code_body = CodeBody::from_set(CodeSet::new(vec![
    ///     Box::new(String::from("Body"))
    /// ]));
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR);
    /// assert_eq!("{\r\n    Body\r\n}", format!("{}", code_body.display(info)));
    /// 
    /// let info = CodeGenerationInfo::from_style(CodeStyle::Horstmann);
    /// assert_eq!("{   Body\r\n}", format!("{}", code_body.display(info)));
    /// ```
    pub fn from_set(code: CodeSet<'a, T>) -> CodeBody<'a, T> {
        CodeBody { raw_code: code }
    }
}

impl<'a, T: GetIter<'a, Item=&'a dyn CodeGenerate>> CodeGenerate for CodeBody<'a, T> {
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let mut result: fmt::Result = fmt::Result::Ok(());
        match info.indent_style {
            IndentationStyle::Allman => {
                result = result.and(Indentation::new().generate(f, info));
                result = result.and(write!(f, "{{"));
                result = result.and(NewLine::new().generate(f, info));
                result = result.and(Indentation::new().generate(f, info.indent()));
                result = result.and(self.raw_code.generate(f, info.indent()));
                result = result.and(NewLine::new().generate(f, info));
                result = result.and(Indentation::new().generate(f, info));
                result = result.and(write!(f, "}}"));
            }
            IndentationStyle::GNU => {
                result = result.and(write!(f, "{{"));
                result = result.and(NewLine::new().generate(f, info));
                result = result.and(Indentation::new().generate(f, info.indent().indent()));
                result = result.and(self.raw_code.generate(f, info.indent().indent()));
                result = result.and(NewLine::new().generate(f, info));
                if info.context != GeneratorContext::Function {
                    result = result.and(Indentation::new().generate(f, info.indent()));
                }
                result = result.and(write!(f, "}}"));
            }
            IndentationStyle::Horstmann => {
                result = result.and(Indentation::new().generate(f, info));
                result = result.and(write!(f, "{{"));
                let mut temp_info = info;
                temp_info.indent_level = 1;
                temp_info.indent_amount -= 1;// to account for '{' if using spaces
                result = result.and(Indentation::new().generate(f, temp_info));
                result = result.and(self.raw_code.generate(f, info.indent()));
                result = result.and(NewLine::new().generate(f, info));
                result = result.and(Indentation::new().generate(f, info));
                result = result.and(write!(f, "}}"));
            }
            IndentationStyle::KnR => {
                result = result.and(write!(f, "{{"));
                result = result.and(NewLine::new().generate(f, info));
                result = result.and(Indentation::new().generate(f, info.indent()));
                result = result.and(self.raw_code.generate(f, info.indent()));
                result = result.and(NewLine::new().generate(f, info));
                result = result.and(Indentation::new().generate(f, info));
                result = result.and(write!(f, "}}"));
            }
            IndentationStyle::Pico => {
                result = result.and(Indentation::new().generate(f, info));
                result = result.and(write!(f, "{{"));
                let mut temp_info = info;
                temp_info.indent_level = 1;
                temp_info.indent_amount -= 1;// to account for '{' if using spaces
                result = result.and(Indentation::new().generate(f, temp_info));
                result = result.and(self.raw_code.generate(f, info.indent()));
                //result = result.and(Indentation::new().generate(f, info));
                result = result.and(write!(f, " }}"));
            }
            IndentationStyle::None => {
                result = result.and(write!(f, "{{"));
                result = result.and(self.raw_code.generate(f, info.indent()));
                result = result.and(write!(f, "}}"));
            }
            _ => result = result.and(write!(f, "NOT SUPPORTED YET!")),
        }

        result
    }
}

pub struct HeaderPlusBody<'a, HT, BT: GetIter<'a, Item=&'a dyn CodeGenerate>> {
    header: HT,
    body: CodeBody<'a, BT>,
}

impl<'a, HT, BT: GetIter<'a, Item=&'a dyn CodeGenerate>> HeaderPlusBody<'a, HT, BT> {
    /// Creates a HeaderPlusBody generator
    /// 
    /// This struct is used for joining headers and bodies. For example joining
    /// the "if(condition)" to the "{body}"
    /// 
    /// ```
    /// # use code_generator::CodeGenerationInfo;
    /// # use code_generator::CodeStyle;
    /// # use code_generator::DisplayExt;
    /// # use code_generator::CodeBody;
    /// # use code_generator::HeaderPlusBody;
    /// #
    /// let header_plus_body = HeaderPlusBody::new(
    ///     String::from("header"),
    ///     CodeBody::new(vec![Box::new(String::from("Body"))])
    /// );
    /// let info = CodeGenerationInfo::from_style(CodeStyle::KnR);
    /// assert_eq!(
    ///     "header {\r\n    Body\r\n}",
    ///     format!("{}", header_plus_body.display(info))
    /// );
    /// 
    /// let info = CodeGenerationInfo::from_style(CodeStyle::Allman);
    /// assert_eq!(
    ///     "header\r\n{\r\n    Body\r\n}",
    ///     format!("{}", header_plus_body.display(info))
    /// );
    /// ```
    pub fn new(header: HT, body: CodeBody<'a, BT>) -> HeaderPlusBody<'a, HT, BT>{
        HeaderPlusBody {header: header, body: body}
    }
}

impl<'a, HT, BT: GetIter<'a, Item=&'a dyn CodeGenerate>> CodeGenerate for HeaderPlusBody<'a, HT, BT>
where HT: CodeGenerate,{
    fn generate(&self, f: &mut fmt::Formatter<'_>, info: CodeGenerationInfo) -> fmt::Result {
        let mut result: fmt::Result = fmt::Result::Ok(());
        result = result.and(self.header.generate(f, info));
        match info.indent_style {
            IndentationStyle::Allman |
            IndentationStyle::Horstmann |
            IndentationStyle::Pico => {
                result = result.and(NewLine::new().generate(f, info));
            },
            IndentationStyle::GNU => {
                result = result.and(NewLine::new().generate(f, info));
                if info.context != GeneratorContext::Function {
                    result = result.and(Indentation::new().generate(f, info.indent()));
                }
            }
            IndentationStyle::KnR => {
                result = result.and(write!(f, " "));
            }
            _ => (),
        }
        result = result.and(self.body.generate(f, info));
        result
    }
}
